# 算法入门概念

## 算法概念

算法 (algorithm)，在数学和计算机科学之中，一个被定义好的、计算机可施行之指示的有限步骤或次序

### 时间复杂度

- 用来估计算法运行时间的一个式子

- **一般来说**，时间复杂度高的算法比低的算法慢
指在机器差不多且问题规模相差不大的情况下

- 常见的时间复杂度
$
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^2logn)<O(n^3)
$

- 复杂问题的时间复杂度
$
O(n!)O(2^n)O(n^n)
$

### 空间复杂度

用来评估算法内存占用大小的一个式子，表示方法与时间复杂度一致

- 算法使用了几个变量：$O(1)$

- 算法使用了长度为 n 的一维列表：$O(n)$

- 算法使用了 m 行 n 列的二维列表：$O(mn)$

### 复习：递归

递归的两个特点：

1. 调用自身

    ```python
    #函数没有调用自身，不是递归
    def sum(x,y):
        return x+y
    ```

2. 结束条件

    ```python
    #没有结束条件 或 结束条件无法导致结束，不是递归
    def add1(x):
        add1(x+1)

    def add2(x):
        if x>0:
            add2(x+1)
    ```

#### 汉诺塔问题

有三根杆子 A，B，C。A 杆上有 N 个 (N>1) 穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至 C 杆：

每次只能移动一个圆盘；
大盘不能叠在小盘上面。

问：如何移？最少要移动多少次？

![Hanoi](./Hanoi.jpg "汉诺塔")

如果只有两个圆盘，我们知道只需要 3 步，而 N 个圆盘可以简化成 N-1 个圆盘加一个圆盘，这就是递归

```python
def hanoi(n):
    if n > 1:
        my_sum = 1 + 2 * hanoi(n - 1)
        return my_sum
    else:
        return 1


print(hanoi(4))
```

## 列表查找

查找：在一些数据元素中，通过一定的方法找出与给定关键字相同的数据
元素的过程。
列表查找（线性表查找）：从列表中查找指定元素

- 输入：列表、待查找元素
- 输出：元素下标（未找到元素时一般返回 None 或 -1）
内置列表查找函数：index()
- 顺序查找
- 二分查找

### 顺序查找

也叫线性查找，从列列表第⼀一个元素开始，顺序进⾏搜索，直到找到元素或搜索到列列表最后⼀一个元素为⽌止。
时间复杂度：O(n)
内置函数`index()`就是顺序查找

```python
def linear_search(li,val):
    for ind, v in enumerate(li):
        if val == v:
            return ind
    return None

```

### 二分查找

又叫折半查找，从**有序**列列表的初始候选区 list[0:n] 开始，通过将*待查找* 的值与候选区*中间值* 比较，可以使候选区减少一半。

```python
def divide(li, val):
    left = 0
    right = len(li) - 1
    while right >= left:
        mid = (left + right) // 2
        if li[mid] > val:
            right = mid - 1
        if li[mid] == val:
            return mid
        if li[mid] < val:
            left = mid + 1
```

## 列表排序

|排序 lowB 三人组|排序 NB 三人组|其它排序|
|---|---|---|
|冒泡排序|快速排序|希尔排序|
|选择排序|堆排序|计数排序|
|插入排序|归并排序|基数排序|

冒泡排序 \ \ \ \ 时间复杂度 $O(n^2)$
优化：如果在一趟遍历中没有发生任何交换，则可以终止排序

选择排序
缺点：多生成一个列表，空间复杂度加倍
优化：选出来的最小值与第一个数交换而不是插入到新的列表

插入排序
用两层循环实现
可以用递归实现，但 python 没有二级指针操作，似乎达不到 $O(n^2)$ 的时间复杂度

### 快速排序

- 快速排序：快
- 快速排序思路：
  1. 取一个元素 p（第一个元素），使元素 p 归位
  2. 列表被分为两部分，左边比p小，右边比p大
  3. 递归完成排序
  
